<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="main_styles.css">
    <!-- Google Fonts for Material Symbols -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />
</head>
<body>
    <aside class="sidebar">
        <header class="sidebar-header">
            <img src="logo.png" alt="SocCalculator" class="header-logo"/>
            <button class="sidebar-toggle">
                <span class="material-symbols-rounded">chevron_left</span>
            </button>
        </header>
        <div class="sidebar-content">
            <!--Menu List-->
            <ul class="menu-list">
                <li class="menu-item">
                    <a href="#" class="menu-link active">
                        <span class="material-symbols-rounded">Home</span>
                        <span class="menu-label">Home</span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="#" class="menu-link" data-page="live-option-chain">
                        <span class="material-symbols-rounded">insert_chart</span>
                        <span class="menu-label">LiveOptionChain</span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="#" class="menu-link">
                        <span class="material-symbols-rounded">database</span>
                        <span class="menu-label">Historical-Chain</span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="#" class="menu-link">
                        <span class="material-symbols-rounded">stacks</span>
                        <span class="menu-label">Oi 2 Oi</span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="#" class="menu-link">
                        <span class="material-symbols-rounded">finance_mode</span>
                        <span class="menu-label">Long-term-Stocks</span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="#" class="menu-link">
                        <span class="material-symbols-rounded">currency_rupee_circle</span>
                        <span class="menu-label">Pricing</span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="#" class="menu-link">
                        <span class="material-symbols-rounded">Settings</span>
                        <span class="menu-label">Settings</span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="#" class="menu-link">
                        <span class="material-symbols-rounded">Group</span>
                        <span class="menu-label">Disclaimer</span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="#" class="menu-link logout-btn">
                        <span class="material-symbols-rounded">Logout</span>
                        <span class="menu-label">Logout</span>
                    </a>
                </li>
            </ul>
        </div>
        <!--sidebar footer-->
        <div class="sidebar-footer">
            <button class="theme-toggle">
                <div class="theme-label">
                    <span class="theme-icon material-symbols-rounded">dark_mode</span>
                    <span class="theme-text">Dark Mode</span>
                </div>
                <div class="theme-toggle-track">
                    <div class="theme-toggle-indicator"></div>
                </div>
            </button>
        </div>
    </aside>
    <script src="main_script.js"></script>
    <main>
        <div class="dropdown-container">
            <select id="scrip" required>
                <option value="" disabled>Select a scrip</option>
            </select>
            <select id="ExpDate" required>
                <option value="" disabled>Select a date</option>
            </select>
        </div>
        <div class="rate-limit-message" id="rateLimitMessage" style="display:none;">Rate limit reached. Retrying...</div>
        <div class="error-message" id="errorMessage" style="display:none;">Error fetching data. Please try again or check the server.</div>
        <table id="chainTable" style="display:none;">
            <thead>
                <tr>
                    <th class="call-column">IV</th>
                    <th class="call-column">TV</th>
                    <th class="call-column">OI Chg (M)</th>
                    <th class="call-column">OI (M)</th>
                    <th class="call-column">Volume (M)</th>
                    <th class="call-column">Chg (%)</th>
                    <th class="call-column">LTP</th>
                    <th id="dateTimeHeader"></th>
                    <th class="put-column">LTP</th>
                    <th class="put-column">Chg (%)</th>
                    <th class="put-column">Volume (M)</th>
                    <th class="put-column">OI (M)</th>
                    <th class="put-column">OI Chg (M)</th>
                    <th class="put-column">TV</th>
                    <th class="put-column">IV</th>
                </tr>
            </thead>
            <tbody id="chainBody"></tbody>
            <tfoot id="totalsFoot"></tfoot>
        </table>
    </main>
    <div class="disclaimer">
        <span class="disclaimer-text">We are not SEBI Registered Advisors. This website is purely for training and educational purposes. We shall not be responsible for your profit or loss. Please confirm with your investment advisor before Trading/Investing.</span>
    </div>
    <script>
        // Global state
        let fetchInterval = null;
        let cachedScrips = null;
        let cachedExpiries = null;
        let lastRequestBody = null;
        let underlyingValue = 0;
        let isError = false;
        let selectedExpiry = null;
        let previousChainData = null;
        let previousMaxStrikes = {
            callOi: null,
            callOiChg: null,
            callVol: null,
            putOi: null,
            putOiChg: null,
            putVol: null
        };
        const nseHolidays2025 = {
            '2025-02-26': 'Mahashivratri',
            '2025-03-14': 'Holi',
            '2025-03-31': 'Id-Ul-Fitr',
            '2025-04-10': 'Shri Mahavir Jayanti',
            '2025-04-14': 'Dr. Baba Saheb Ambedkar Jayanti',
            '2025-04-18': 'Good Friday',
            '2025-05-01': 'Maharashtra Day',
            '2025-08-15': 'Independence Day',
            '2025-08-27': 'Ganesh Chaturthi',
            '2025-10-02': 'Mahatma Gandhi Jayanti/Dussehra',
            '2025-10-21': 'Diwali Laxmi Pujan',
            '2025-10-22': 'Diwali-Balipratipada',
            '2025-11-05': 'Prakash Gurpurb Sri Guru Nanak Dev',
            '2025-12-25': 'Christmas'
        };
        const BASE_URL = 'http://127.0.0.1:5000';
        let retryCount = 0;
        const MAX_RETRIES = 5;
        const RETRY_DELAY = 10000;
        const FALLBACK_DELAY = 60000;
        let lastFetchTime = 0;
        const MIN_FETCH_INTERVAL = 5000;
        let currentZoomLevel = 1.0;
        let currentPopup = null;
        let hasSetNineThirty = false;
        let nineThirtyData = null;
        let strikeLevels = new Map();
        let nineThirtyStrikeLevels = new Map();
        const RISK_FREE_RATE = 0.067;

        // Logout functionality
        document.querySelector(".logout-btn").addEventListener("click", (e) => {
            e.preventDefault();
            localStorage.removeItem("currentUser");
            window.location.href = "login_index.html";
        });

        function setZoomLevel(zoom) {
            currentZoomLevel = parseFloat(zoom);
            document.querySelector('main').style.transform = `scale(${currentZoomLevel})`;
            document.querySelector('main').style.transformOrigin = 'top left';
            document.querySelector('main').style.width = `${100 / currentZoomLevel}%`;
            document.querySelector('main').style.height = `${100 / currentZoomLevel}%`;
            document.getElementById('zoomValue').textContent = `${Math.round(currentZoomLevel * 100)}%`;
            if (currentPopup) {
                const strike = currentPopup.dataset.strike;
                const cellElement = document.querySelector(`#chainTable td[data-strike="${strike}"]`) ||
                                   document.querySelector(`#chainTable td[data-strike="${strike}"][data-type]`);
                if (cellElement) {
                    const rect = cellElement.getBoundingClientRect();
                    const table = document.getElementById('chainTable');
                    const tableRect = table.getBoundingClientRect();
                    currentPopup.style.left = `${(rect.left - tableRect.left + rect.width) / currentZoomLevel}px`;
                    currentPopup.style.top = `${(rect.top - tableRect.top + rect.height) / currentZoomLevel}px`;
                }
            }
        }
        function formatTimestamp() {
            const now = new Date();
            const options = {
                day: '2-digit',
                month: 'short',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            };
            return now.toLocaleString('en-IN', options).replace(/(\d{2}:\d{2}:\d{2})\s(\w+)/, '$1 $2');
        }
        function isSameTradingDay(date1, date2) {
            return date1.toISOString().split('T')[0] === date2.toISOString().split('T')[0];
        }
        function isTradingDay(date) {
            const day = date.getDay();
            const dateStr = date.toISOString().split('T')[0];
            return day !== 0 && day !== 6 && !nseHolidays2025[dateStr];
        }
        function showElasticEndsPopup(strike, cellElement) {
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }
            const current = strikeLevels.get(strike) || { support: 0, resistance: 0 };
            let nineThirty = nineThirtyStrikeLevels.get(strike) || { support: 0, resistance: 0 };
            if (!hasSetNineThirty || !isSameTradingDay(new Date(), new Date(nineThirtyData?.date))) {
                nineThirty = { support: 0, resistance: 0 };
            }
            const popup = document.createElement('div');
            popup.classList.add('inline-popup');
            popup.dataset.strike = strike;
            popup.innerHTML = `
                <div class="popup-content">
                    <h3>Elastic Ends for Strike ${strike}</h3>
                    <div>
                        <p><strong>Current Elastic Ends</strong></p>
                        <p class="resistance">Resistance: ${current.resistance}</p>
                        <p class="support">Support: ${current.support}</p>
                    </div>
                    <div class="divider"></div>
                    <div>
                        <p><strong>9:30 AM Elastic Ends</strong></p>
                        ${hasSetNineThirty && isSameTradingDay(new Date(), new Date(nineThirtyData?.date))
                            ? `<p class="resistance">Resistance: ${nineThirty.resistance}</p>
                               <p class="support">Support: ${nineThirty.support}</p>`
                            : '<p>Not fetched today\'s values at 9:30 AM</p>'}
                    </div>
                    <button>Close</button>
                </div>
            `;
            const rect = cellElement.getBoundingClientRect();
            const table = document.getElementById('chainTable');
            const tableRect = table.getBoundingClientRect();
            popup.style.position = 'absolute';
            popup.style.left = `${(rect.left - tableRect.left + rect.width) / currentZoomLevel}px`;
            popup.style.top = `${(rect.top - tableRect.top + rect.height) / currentZoomLevel}px`;
            table.appendChild(popup);
            currentPopup = popup;
            popup.querySelector('button').onclick = () => {
                popup.remove();
                currentPopup = null;
            };
            document.addEventListener('click', function handler(event) {
                if (!popup.contains(event.target) && !cellElement.contains(event.target)) {
                    popup.remove();
                    currentPopup = null;
                    document.removeEventListener('click', handler);
                }
            }, { once: true });
        }
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        function throttle(func) {
            return function (...args) {
                const now = Date.now();
                if (now - lastFetchTime >= MIN_FETCH_INTERVAL) {
                    lastFetchTime = now;
                    return func(...args);
                } else {
                    console.log('Throttled fetch attempt');
                }
            };
        }
        function toggleNavMenu() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('open');
        }
        function toggleDropdown(event) {
            event.stopPropagation();
            const dropdown = event.target.closest('.dropdown');
            if (dropdown) {
                dropdown.classList.toggle('active');
                const select = dropdown.querySelector('select');
                if (select) {
                    select.addEventListener('click', (e) => e.stopPropagation());
                    select.addEventListener('change', (e) => e.stopPropagation());
                }
            }
        }
        document.querySelectorAll('.nav-menu a, .dropdown').forEach(element => {
            element.addEventListener('click', (event) => {
                if (element.classList.contains('dropdown')) {
                    toggleDropdown(event);
                } else if (!element.closest('select') &&
                         !element.closest('input[type="radio"]') &&
                         !element.closest('#zoomLevel')) {
                    document.querySelector('.sidebar').classList.remove('open');
                }
            });
        });
        function showRateLimitMessage() {
            const rateLimitDiv = document.getElementById('rateLimitMessage');
            if (rateLimitDiv) {
                rateLimitDiv.style.display = 'block';
            }
        }
        function hideRateLimitMessage() {
            const rateLimitDiv = document.getElementById('rateLimitMessage');
            if (rateLimitDiv) {
                rateLimitDiv.style.display = 'none';
            }
        }
        let scripList = [];
        async function fetchScrips() {
            try {
                const response = await fetch(`${BASE_URL}/get_all_scrips`);
                if (!response.ok) {
                    console.error('Failed to fetch /get_all_scrips:', response.status, response.statusText);
                    showErrorMessage('Failed to fetch scrips: ' + response.statusText);
                    return;
                }
                const data = await response.json();
                if (data.error) {
                    showErrorMessage('Backend error: ' + data.error);
                    return;
                }
                if (!Array.isArray(data) || data.length === 0) {
                    showErrorMessage('No scrips available for dropdown.');
                    return;
                }
                scripList = data;
                renderScrips(data);
                setDefaultNifty();
            } catch (error) {
                showErrorMessage('Failed to fetch scrips');
                console.error('Fetch error:', error);
            }
        }
        function renderScrips(data) {
            const scripSelect = document.getElementById('scrip');
            scripSelect.innerHTML = '<option value="" disabled>Select a scrip</option>';
            data.forEach(scrip => {
                const symbol = scrip.symbol || 'Unknown';
                const option = document.createElement('option');
                option.value = scrip.scrip_id + '|' + scrip.segment;
                option.text = symbol;
                scripSelect.appendChild(option);
            });
            scripSelect.disabled = false;
        }
        function setDefaultNifty() {
            const scripSelect = document.getElementById('scrip');
            const niftyOption = Array.from(scripSelect.options).find(option => option.text.toUpperCase() === 'NIFTY' || option.text.toUpperCase().includes('NIFTY'));
            if (niftyOption) {
                scripSelect.value = niftyOption.value;
                const [scrip_id, segment] = niftyOption.value.split('|');
                window.selectedScripId = scrip_id;
                window.selectedSegment = segment;
                fetchExpiries();
            } else {
                showErrorMessage('Nifty not found in scrip list.');
            }
        }
        document.getElementById('scrip').addEventListener('change', () => {
            stopFetching();
            previousChainData = null;
            previousMaxStrikes = { callOi: null, callOiChg: null, callVol: null, putOi: null, putOiChg: null, putVol: null };
            const selected = document.getElementById('scrip').value;
            if (!selected) return;
            const [scrip_id, segment] = selected.split('|');
            window.selectedScripId = scrip_id;
            window.selectedSegment = segment;
            fetchExpiries();
        });
        async function fetchExpiries() {
            const scrip_id = window.selectedScripId;
            const segment = window.selectedSegment;
            if (!scrip_id || !segment) {
                showErrorMessage('Please select a scrip.');
                return;
            }
            try {
                const response = await fetch(`${BASE_URL}/get_expiries`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        underlying_scrip: parseInt(scrip_id),
                        underlying_seg: segment
                    })
                });
                const data = await response.json();
                if (!data.data) {
                    throw new Error(data.error || 'Invalid response format');
                }
                cachedExpiries = { scrip: scrip_id, seg: segment, data: data.data };
                renderExpiries(data.data);
            } catch (error) {
                console.error('Fetch error:', error);
                showErrorMessage(error.message);
            }
        }
        function renderExpiries(expiries) {
            const ExpSelect = document.getElementById('ExpDate');
            ExpSelect.innerHTML = '<option value="" disabled>Select a date</option>';
            if (!expiries || !Array.isArray(expiries) || expiries.length === 0) {
                showErrorMessage('No valid expiry dates available in response.');
                return;
            }
            console.log('Dropdown data:', expiries);
            expiries.forEach(item => {
                const option = document.createElement('option');
                option.value = item;
                option.textContent = String(item);
                ExpSelect.appendChild(option);
            });
            ExpSelect.disabled = false;
            const selected = document.getElementById('ExpDate').value;
            if (!selected) return;
            selectedExpiry = selected;
            startFetching();
        }
        async function fetchChain() {
            const scrip_id = window.selectedScripId;
            const segment = window.selectedSegment;
            const strikeOption = document.querySelector('input[name="strikeOption"]:checked')?.value || '12';
            const tableOrder = document.querySelector('input[name="tableOrder"]:checked')?.value || 'descending';
            if (!scrip_id || !segment || !selectedExpiry) {
                showErrorMessage('Please select a scrip and ensure an expiry is available.');
                return;
            }
            const requestBody = { underlying_scrip: parseInt(scrip_id), underlying_seg: segment, expiry: selectedExpiry };
            console.log('Sending request to /get_option_chain:', JSON.stringify(requestBody, null, 2));
            if (lastRequestBody && JSON.stringify(requestBody) === JSON.stringify(lastRequestBody) &&
                strikeOption === lastRequestBody.strikeOption && tableOrder === lastRequestBody.tableOrder) {
                console.log('Skipping duplicate fetch with same parameters');
                return;
            }
            lastRequestBody = { ...requestBody, strikeOption, tableOrder };
            console.log('Fetching chain with:', JSON.stringify(requestBody, null, 2), 'strikeOption:', strikeOption, 'tableOrder:', tableOrder);
            async function attemptFetch(attempt) {
                try {
                    const response = await fetch(`${BASE_URL}/get_option_chain`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json; charset=utf-8' },
                        body: JSON.stringify(requestBody)
                    });
                    const data = await response.json();
                    console.log('Raw chain response:', JSON.stringify(data, null, 2));
                    if (data.error) {
                        showErrorMessage(`Error fetching chain: ${data.error}`);
                        return;
                    }
                    if (data.from_cache) {
                        document.getElementById('rateLimitMessage').textContent = 'Data from cache';
                        document.getElementById('rateLimitMessage').style.display = 'block';
                        setTimeout(() => hideRateLimitMessage(), 2000);
                    }
                    underlyingValue = data.spot_price || data.underlying_price || 0;
                    checkAndSetNineThirtyData(data);
                    renderTable(data, strikeOption, tableOrder);
                    previousChainData = data;
                    removeErrorMessage();
                    hideRateLimitMessage();
                    retryCount = 0;
                } catch (error) {
                    showErrorMessage(`Failed to fetch chain: ${error.message}`);
                    console.error('Fetch error:', error);
                }
            }
            await attemptFetch(1);
        }
        function renderTable(data, strikeOption, tableOrder) {
            const tbody = document.getElementById('chainBody');
            const tfoot = document.getElementById('totalsFoot');
            const dateTimeHeader = document.getElementById('dateTimeHeader');
            const timestamp = formatTimestamp();
            const [date, time] = timestamp.split(', ');
            dateTimeHeader.innerHTML = `${date}<br>${time}`;
            let filteredChain = data.chain;
            if (strikeOption === '12') {
                const spotPrice = underlyingValue;
                if (spotPrice === 0) {
                    console.warn('Spot price unavailable, showing all strikes.');
                } else {
                    const sortedStrikes = data.chain.map(row => row.strike).sort((a, b) => a - b);
                    const strikesAbove = sortedStrikes.filter(strike => strike >= spotPrice).slice(0, 12);
                    const strikesBelow = sortedStrikes.filter(strike => strike < spotPrice).slice(-12);
                    const selectedStrikes = [...strikesBelow, ...strikesAbove].sort((a, b) => a - b);
                    filteredChain = data.chain.filter(row => selectedStrikes.includes(row.strike));
                }
            }
            filteredChain.sort((a, b) => tableOrder === 'ascending' ? a.strike - b.strike : b.strike - a.strike);
            const maxValues = {
                callOiChg: { max: 0, second: 0, third: 0, maxStrike: null },
                callOi: { max: 0, second: 0, third: 0, maxStrike: null },
                callVol: { max: 0, second: 0, third: 0, maxStrike: null },
                putVol: { max: 0, second: 0, third: 0, maxStrike: null },
                putOi: { max: 0, second: 0, third: 0, maxStrike: null },
                putOiChg: { max: 0, second: 0, third: 0, maxStrike: null }
            };
            const getTopThree = (values, strikes) => {
                const validValues = values
                    .map((v, i) => ({ value: v, strike: strikes[i] }))
                    .filter(item => item.value > 0)
                    .sort((a, b) => b.value - a.value);
                return {
                    max: validValues[0]?.value || 0,
                    second: validValues[1]?.value || 0,
                    third: validValues[2]?.value || 0,
                    maxStrike: validValues[0]?.strike || null
                };
            };
            const strikes = filteredChain.map(row => row.strike);
            maxValues.callOiChg = getTopThree(filteredChain.map(row => row.call_oi_chg >= 0 ? row.call_oi_chg : 0), strikes);
            maxValues.callOi = getTopThree(filteredChain.map(row => row.call_oi >= 0 ? row.call_oi : 0), strikes);
            maxValues.callVol = getTopThree(filteredChain.map(row => Math.abs(row.call_vol || 0)), strikes);
            maxValues.putVol = getTopThree(filteredChain.map(row => Math.abs(row.put_vol || 0)), strikes);
            maxValues.putOi = getTopThree(filteredChain.map(row => row.put_oi >= 0 ? row.put_oi : 0), strikes);
            maxValues.putOiChg = getTopThree(filteredChain.map(row => row.put_oi_chg >= 0 ? row.put_oi_chg : 0), strikes);
            const shifts = [];
            const metrics = [
                { key: 'callOi', name: 'Call OI', current: maxValues.callOi.maxStrike, previous: previousMaxStrikes.callOi },
                { key: 'callOiChg', name: 'Call OI Chg', current: maxValues.callOiChg.maxStrike, previous: previousMaxStrikes.callOiChg },
                { key: 'callVol', name: 'Call Vol', current: maxValues.callVol.maxStrike, previous: previousMaxStrikes.callVol },
                { key: 'putOi', name: 'Put OI', current: maxValues.putOi.maxStrike, previous: previousMaxStrikes.putOi },
                { key: 'putOiChg', name: 'Put OI Chg', current: maxValues.putOiChg.maxStrike, previous: previousMaxStrikes.putOiChg },
                { key: 'putVol', name: 'Put Vol', current: maxValues.putVol.maxStrike, previous: previousMaxStrikes.putVol }
            ];
            if (previousChainData) {
                metrics.forEach(metric => {
                    if (metric.current !== null && metric.previous !== null && metric.current !== metric.previous) {
                        const direction = metric.current > metric.previous ? 'up' : 'down';
                        const timestamp = formatTimestamp().split(', ')[1];
                        shifts.push({
                            metric: metric.name,
                            from: metric.previous,
                            to: metric.current,
                            direction: direction,
                            timestamp: timestamp
                        });
                    }
                });
            }
            previousMaxStrikes = {
                callOi: maxValues.callOi.maxStrike,
                callOiChg: maxValues.callOiChg.maxStrike,
                callVol: maxValues.callVol.maxStrike,
                putOi: maxValues.putOi.maxStrike,
                putOiChg: maxValues.putOiChg.maxStrike,
                putVol: maxValues.putVol.maxStrike
            };
            const spotPrice = underlyingValue;
            let spotRowIndex = -1;
            if (spotPrice > 0) {
                const sortedStrikes = filteredChain.map(row => row.strike);
                spotRowIndex = tableOrder === 'ascending'
                    ? sortedStrikes.findIndex((strike, index) => index < sortedStrikes.length - 1 && strike <= spotPrice && sortedStrikes[index + 1] > spotPrice)
                    : sortedStrikes.findIndex((strike, index) => index < sortedStrikes.length - 1 && strike > spotPrice && sortedStrikes[index + 1] <= spotPrice);
            }
            const fragment = document.createDocumentFragment();
            let spotRowInserted = false; // Define spotRowInserted here
            if (shifts.length > 0) {
                shifts.forEach(shift => {
                    const shiftRow = document.createElement('tr');
                    shiftRow.classList.add('shift-row');
                    const message = `${shift.metric} --> ${shift.from.toFixed(2)} --> ${shift.to.toFixed(2)} at ${shift.timestamp}`;
                    shiftRow.innerHTML = `<td colspan="7"></td><td><span class="shift-${shift.direction}">${message}</span></td><td colspan="7"></td>`;
                    fragment.appendChild(shiftRow);
                });
            }
            filteredChain.forEach((row, index) => {
                if (!spotRowInserted && spotPrice > 0 && spotRowIndex !== -1 && index === spotRowIndex + 1) {
                    const spotRow = document.createElement('tr');
                    spotRow.classList.add('spot-row');
                    spotRow.innerHTML = `<td colspan="7"></td><td>Spot Price: ${spotPrice.toFixed(2)}</td><td colspan="7"></td>`;
                    fragment.appendChild(spotRow);
                    spotRowInserted = true;
                }
                const dataRow = document.createElement('tr');
                if (spotPrice > 0 && row.strike < spotPrice) {
                    dataRow.classList.add('itm');
                } else if (spotPrice > 0 && row.strike > spotPrice) {
                    dataRow.classList.add('otm');
                }
                function createTd(value, isChg = false, isMillion = false, maxValue = null, isPut = false, isOiOrOiChg = false, isStrike = false) {
                    const td = document.createElement('td');
                    if (isMillion && value !== null && value !== undefined && Number.isFinite(value)) {
                        let percent;
                        let className = '';
                        if (isOiOrOiChg && value < 0) {
                            percent = '0';
                        } else {
                            percent = maxValue.max > 0 ? (value / maxValue.max * 100).toFixed(1) : '0';
                            if (value === maxValue.max) {
                                className = isPut ? 'highest-value-put' : 'highest-value-call';
                            } else if (value === maxValue.second && percent > 75) {
                                className = 'second-highest';
                            } else if (value === maxValue.third && percent > 75) {
                                className = 'third-highest';
                            }
                        }
                        td.textContent = `${percent}%\n${(value / 1000000).toFixed(1)}M`;
                        if (className) {
                            td.classList.add(className);
                        }
                    } else {
                        td.textContent = value !== null && value !== undefined ? Number.isFinite(value) ? value.toFixed(2) : value : '-';
                    }
                    if (isChg && Number.isFinite(value)) {
                        if (value > 0) td.classList.add('positive');
                        else if (value < 0) td.classList.add('negative');
                    }
                    if (isStrike) {
                        td.style.cursor = 'pointer';
                        td.dataset.strike = row.strike;
                        td.addEventListener('click', (event) => showElasticEndsPopup(row.strike, td));
                    }
                    return td;
                }
                dataRow.appendChild(createTd(row.call_iv));
                dataRow.appendChild(createTd(row.call_tv));
                dataRow.appendChild(createTd(row.call_oi_chg, true, true, maxValues.callOiChg, false, true));
                dataRow.appendChild(createTd(row.call_oi, false, true, maxValues.callOi, false, true));
                dataRow.appendChild(createTd(row.call_vol, false, true, maxValues.callVol));
                dataRow.appendChild(createTd(row.call_chg_pct, true));
                dataRow.appendChild(createTd(row.call_ltp));
                dataRow.appendChild(createTd(row.strike, false, false, null, false, false, true));
                dataRow.appendChild(createTd(row.put_ltp));
                dataRow.appendChild(createTd(row.put_chg_pct, true));
                dataRow.appendChild(createTd(row.put_vol, false, true, maxValues.putVol, true));
                dataRow.appendChild(createTd(row.put_oi, false, true, maxValues.putOi, true, true));
                dataRow.appendChild(createTd(row.put_oi_chg, true, true, maxValues.putOiChg, true, true));
                dataRow.appendChild(createTd(row.put_tv));
                dataRow.appendChild(createTd(row.put_iv));
                fragment.appendChild(dataRow);
            });
            if (!spotRowInserted && spotPrice > 0) {
                const spotRow = document.createElement('tr');
                spotRow.classList.add('spot-row');
                spotRow.innerHTML = `<td colspan="7"></td><td>Spot Price: ${spotPrice.toFixed(2)}</td><td colspan="7"></td>`;
                fragment.appendChild(spotRow);
            }
            const totalRow = document.createElement('tr');
            totalRow.classList.add('total-row');
            totalRow.innerHTML = `
                <td></td>
                <td></td>
                <td></td>
                <td>${data.totals.total_call_oi !== undefined ? (data.totals.total_call_oi / 1000000).toFixed(1) + 'M' : '-'}</td>
                <td>${data.totals.total_call_vol !== undefined ? (data.totals.total_call_vol / 1000000).toFixed(1) + 'M' : '-'}</td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td>${data.totals.total_put_vol !== undefined ? (data.totals.total_put_vol / 1000000).toFixed(1) + 'M' : '-'}</td>
                <td>${data.totals.total_put_oi !== undefined ? (data.totals.total_put_oi / 1000000).toFixed(1) + 'M' : '-'}</td>
                <td></td>
                <td></td>
                <td></td>
            `;
            const pcrRow = document.createElement('tr');
            pcrRow.classList.add('pcr-row');
            pcrRow.innerHTML = `
                <td colspan="15">Total PCR OI: ${data.totals.total_pcr_oi !== undefined ? data.totals.total_pcr_oi.toFixed(2) : '-'} | Total PCR Vol: ${data.totals.total_pcr_vol !== undefined ? data.totals.total_pcr_vol.toFixed(2) : '-'}</td>
            `;
            tfoot.innerHTML = '';
            tfoot.appendChild(totalRow);
            tfoot.appendChild(pcrRow);
            tbody.innerHTML = '';
            tbody.appendChild(fragment);
            document.getElementById('chainTable').style.display = 'table';
            calculateStrikeLevels(data.chain);
            if (nineThirtyData) {
                calculateNineThirtyStrikeLevels();
            }
        }
        function calculateT() {
            const now = new Date();
            const expiryDate = new Date(`${selectedExpiry}T15:30:00+05:30`);
            const diffMs = expiryDate - now;
            if (diffMs <= 0) {
                return 0;
            }
            const diffDaysFractional = diffMs / (1000 * 60 * 60 * 24);
            const days = Math.ceil(diffDaysFractional);
            return days / 365;
        }
        function calculateReversal(row, useNineThirty = false) {
            let S = underlyingValue;
            let P = row.put_ltp;
            let C = row.call_ltp;
            const K = row.strike;
            if (useNineThirty && nineThirtyData) {
                S = nineThirtyData.s;
                const strikeData = nineThirtyData.strikes.get(K);
                if (strikeData) {
                    P = strikeData.p;
                    C = strikeData.c;
                } else {
                    return 0;
                }
            }
            const t = calculateT();
            const exp_term = Math.exp(-RISK_FREE_RATE * t);
            const one_minus_exp = 1 - exp_term;
            const reversal = S - K + P - C + K * one_minus_exp;
            return K + reversal;
        }
        function calculateStrikeLevels(chain) {
            const sortedChain = [...chain].sort((a, b) => a.strike - b.strike);
            if (sortedChain.length < 1) return;
            strikeLevels.clear();
            const step = sortedChain.length > 1 ? sortedChain[1].strike - sortedChain[0].strike : 50;
            const lowestRow = sortedChain[0];
            const hypotheticalLow = { ...lowestRow, strike: lowestRow.strike - step };
            const lowSupport = calculateReversal(hypotheticalLow);
            for (let i = 0; i < sortedChain.length; i++) {
                const row = sortedChain[i];
                const support = i === 0 ? lowSupport : calculateReversal(row);
                let resistance;
                if (i < sortedChain.length - 1) {
                    resistance = calculateReversal(sortedChain[i + 1]);
                } else {
                    const hypotheticalHigh = { ...row, strike: row.strike + step };
                    resistance = calculateReversal(hypotheticalHigh);
                }
                strikeLevels.set(row.strike, { support: support.toFixed(4), resistance: resistance.toFixed(4) });
            }
        }
        function calculateNineThirtyStrikeLevels() {
            if (!nineThirtyData || !nineThirtyData.strikes.size) return;
            const strikesArray = Array.from(nineThirtyData.strikes.keys()).sort((a, b) => a - b);
            const chain = strikesArray.map(strike => ({
                strike,
                put_ltp: nineThirtyData.strikes.get(strike).p,
                call_ltp: nineThirtyData.strikes.get(strike).c
            }));
            nineThirtyStrikeLevels.clear();
            const step = strikesArray.length > 1 ? strikesArray[1] - strikesArray[0] : 50;
            const lowestStrike = strikesArray[0];
            const lowestData = nineThirtyData.strikes.get(lowestStrike);
            const hypotheticalLow = { strike: lowestStrike - step, put_ltp: lowestData.p, call_ltp: lowestData.c };
            const lowSupport = calculateReversal(hypotheticalLow, true);
            for (let i = 0; i < strikesArray.length; i++) {
                const row = chain[i];
                const support = i === 0 ? lowSupport : calculateReversal(row, true);
                let resistance;
                if (i < strikesArray.length - 1) {
                    resistance = calculateReversal(chain[i + 1], true);
                } else {
                    const hypotheticalHigh = { ...row, strike: row.strike + step };
                    resistance = calculateReversal(hypotheticalHigh, true);
                }
                nineThirtyStrikeLevels.set(row.strike, { support: support.toFixed(4), resistance: resistance.toFixed(4) });
            }
        }
        function loadNineThirtyData() {
            const storedData = localStorage.getItem('nineThirtyData');
            if (storedData) {
                const parsedData = JSON.parse(storedData);
                const now = new Date();
                const storedDate = new Date(parsedData.date);
                if (isSameTradingDay(now, storedDate)) {
                    nineThirtyData = {
                        s: parsedData.s,
                        strikes: new Map(Object.entries(parsedData.strikes).map(([k, v]) => [Number(k), v])),
                        date: parsedData.date
                    };
                    nineThirtyStrikeLevels = new Map(Object.entries(parsedData.strikeLevels || {}).map(([k, v]) => [Number(k), v]));
                    hasSetNineThirty = true;
                } else {
                    localStorage.removeItem('nineThirtyData');
                    nineThirtyData = null;
                    nineThirtyStrikeLevels = new Map();
                    hasSetNineThirty = false;
                }
            }
        }
        function checkAndSetNineThirtyData(data) {
            const now = new Date();
            const isTrading = isTradingDay(now);
            if (isTrading && !hasSetNineThirty) {
                const nineThirty = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 9, 30, 0);
                if (now >= nineThirty && now <= new Date(now.getFullYear(), now.getMonth(), now.getDate(), 9, 31, 0)) {
                    setNineThirtyData(data);
                }
            }
        }
        function setNineThirtyData(data) {
            if (nineThirtyData || !data.chain.length) return;
            nineThirtyData = {
                s: data.underlying_price,
                strikes: new Map(),
                date: new Date().toISOString().split('T')[0]
            };
            data.chain.forEach(row => {
                nineThirtyData.strikes.set(row.strike, { p: row.put_ltp, c: row.call_ltp });
            });
            saveNineThirtyData();
            calculateNineThirtyStrikeLevels();
            hasSetNineThirty = true;
        }
        function saveNineThirtyData() {
            if (nineThirtyData) {
                const dataToSave = {
                    s: nineThirtyData.s,
                    strikes: Object.fromEntries(nineThirtyData.strikes),
                    date: nineThirtyData.date,
                    strikeLevels: Object.fromEntries(nineThirtyStrikeLevels)
                };
                localStorage.setItem('nineThirtyData', JSON.stringify(dataToSave));
            }
        }
        function startFetching() {
            debouncedFetchChain();
            fetchInterval = setInterval(debouncedFetchChain, 10000);
        }
        function stopFetching() {
            if (fetchInterval) {
                clearInterval(fetchInterval);
                fetchInterval = null;
            }
            hideRateLimitMessage();
        }
        const debouncedFetchChain = debounce(throttle(fetchChain), 5000);
        function showErrorMessage(message) {
            isError = true;
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
            console.log('Error displayed:', message);
            stopFetching();
        }
        function removeErrorMessage() {
            isError = false;
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }
        document.querySelectorAll('input[name="strikeOption"], input[name="tableOrder"]').forEach(input => {
            input.addEventListener('change', debouncedFetchChain);
        });
        document.addEventListener('DOMContentLoaded', () => {
            loadNineThirtyData();
            fetchScrips();
        });
        // Handle sidebar menu navigation for LiveOptionChain
        document.addEventListener('click', (event) => {
           const menuLink = event.target.closest('.menu-link[data-page="live-option-chain"]');
           if (menuLink) {
                event.preventDefault();
                document.querySelectorAll('.menu-link').forEach(link => link.classList.remove('active'));
                menuLink.classList.add('active');
                console.log('Loading Live Option Chain for Nifty...');
                stopFetching();
                fetchScrips();
                document.getElementById('chainTable').style.display = 'block';
            }
        });
    </script>
</body>
</html>