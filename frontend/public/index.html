<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Option Chain</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        #oiChart {
            display: block;
            max-width: 800px;
            margin: 20px auto;
        }
        .inline-popup {
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            padding: 10px;
        }
        .popup-content {
            max-width: 600px;
        }
        .popup-chart {
            width: 500px;
            height: 200px;
            margin-top: 10px;
            margin-bottom: 20px;
        }
        .divider {
            border-top: 1px solid #ccc;
            margin: 10px 0;
        }
        .dropdown-menu {
            display: none;
            position: absolute;
            background: #fff;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
        }

        .dropdown-menu select {
            width: 200px;
            padding: 5px;
            margin: 5px 0;
        }

        .dropdown:hover .dropdown-menu,
        .dropdown.active .dropdown-menu,
        .dropdown-menu:hover {
            display: block;
        }

        .dropdown-menu:focus-within {
            display: block;
        }
    </style>
</head>
<body>
    <nav class="nav-container">
        <button class="hamburger" aria-label="Toggle menu">â˜°</button>
        <ul class="nav-menu open">
            <li><a href="#home">Home</a></li>
            <li class="dropdown">
                <a href="#instruments">Instruments</a>
                <ul class="dropdown-menu">
                    <li>
                        <select id="scrip" required>
                            <option value="" disabled>Select a scrip</option>
                        </select>
                    </li>
                </ul>
            </li>
            <li class="dropdown">
                <a href="#settings">Settings</a>
                <ul class="dropdown-menu">
                    <li>
                        <fieldset>
                            <legend>Select Strike Prices:</legend>
                            <label><input type="radio" name="strikeOption" value="all"> All Strikes</label>
                            <label><input type="radio" name="strikeOption" value="12" checked> Near Strike Price</label>
                        </fieldset>
                    </li>
                    <li>
                        <fieldset>
                            <legend>Table Order:</legend>
                            <label><input type="radio" name="tableOrder" value="ascending"> Top to Bottom</label>
                            <label><input type="radio" name="tableOrder" value="descending" checked> Bottom to Top</label>
                        </fieldset>
                    </li>
                    <li>
                        <fieldset>
                            <legend>Zoom Level (50% - 100%):</legend>
                            <input type="range" id="zoomLevel" min="0.5" max="1.0" step="0.05" value="1.0" oninput="setZoomLevel(this.value)">
                            <span id="zoomValue">100%</span>
                        </fieldset>
                    </li>
                </ul>
            </li>
            <li><a href="#about">About</a></li>
            <li class="dropdown">
                <a href="#Expiry dates">Expiry dates</a>
                <ul class="dropdown-menu">
                    <li>
                        <select id="ExpDate" required>
                            <option value="" disabled>Select a date</option>
                        </select>
                    </li>
                </ul>
            </li>
        </ul>
    </nav>

    <div class="rate-limit-message" id="rateLimitMessage" style="display:none;">Rate limit reached. Retrying...</div>
    <div class="error-message" id="errorMessage" style="display:none;">Error fetching data. Please try again or check the server.</div>
    <table id="chainTable" style="display:none;">
        <thead>
            <tr>
                <th class="call-column">IV</th>
                <th class="call-column">TV</th>
                <th class="call-column">OI Chg (M)</th>
                <th class="call-column">OI (M)</th>
                <th class="call-column">Volume (M)</th>
                <th class="call-column">Chg (%)</th>
                <th class="call-column">LTP</th>
                <th id="dateTimeHeader"></th>
                <th class="put-column">LTP</th>
                <th class="put-column">Chg (%)</th>
                <th class="put-column">Volume (M)</th>
                <th class="put-column">OI (M)</th>
                <th class="put-column">OI Chg (M)</th>
                <th class="put-column">TV</th>
                <th class="put-column">IV</th>
            </tr>
        </thead>
        <tbody id="chainBody"></tbody>
        <tfoot id="totalsFoot"></tfoot>
    </table>
    <div>
        <canvas id="oiChart" width="800" height="400"></canvas>
    </div>
    <div class="disclaimer">
        <span class="disclaimer-text">We are not SEBI Registered Advisors. This website is purely for training and educational purposes. We shall not be responsible for your profit or loss. Please confirm with your investment advisor before Trading/Investing.</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script>
        // Global state
        let fetchInterval = null;
        let cachedScrips = null;
        let cachedExpiries = null;
        let lastRequestBody = null;
        let underlyingValue = 0;
        let isError = false;
        let selectedExpiry = null;
        let previousChainData = null;
        let previousMaxStrikes = {
            callOi: null,
            callOiChg: null,
            callVol: null,
            putOi: null,
            putOiChg: null,
            putVol: null
        };
        const nseHolidays2025 = {
            '2025-02-26': 'Mahashivratri',
            '2025-03-14': 'Holi',
            '2025-03-31': 'Id-Ul-Fitr',
            '2025-04-10': 'Shri Mahavir Jayanti',
            '2025-04-14': 'Dr. Baba Saheb Ambedkar Jayanti',
            '2025-04-18': 'Good Friday',
            '2025-05-01': 'Maharashtra Day',
            '2025-08-15': 'Independence Day',
            '2025-08-27': 'Ganesh Chaturthi',
            '2025-10-02': 'Mahatma Gandhi Jayanti/Dussehra',
            '2025-10-21': 'Diwali Laxmi Pujan',
            '2025-10-22': 'Diwali-Balipratipada',
            '2025-11-05': 'Prakash Gurpurb Sri Guru Nanak Dev',
            '2025-12-25': 'Christmas'
        };
        const BASE_URL = 'http://127.0.0.1:5000';
        let retryCount = 0;
        const MAX_RETRIES = 5;
        const RETRY_DELAY = 10000;
        const FALLBACK_DELAY = 60000;
        let lastFetchTime = 0;
        const MIN_FETCH_INTERVAL = 5000;
        let currentZoomLevel = 1.0;
        let currentPopup = null;
        let oiChart = null;
        let chartDataPoints = {
            timestamps: [],
            oiChangePE: [],
            oiChangeCE: [],
            oiChangePEMinusCE: []
        };
        let strikeOiChangeData = new Map(); // Store OI change, VOI, and OI data per strike

        // Elastic Ends state
        let hasSetNineThirty = false;
        let nineThirtyData = null;
        let strikeLevels = new Map();
        let nineThirtyStrikeLevels = new Map();
        const RISK_FREE_RATE = 0.067;

        // Chart.js plugin for black background
        const blackBackgroundPlugin = {
            id: 'blackBackground',
            beforeDraw: (chart) => {
                const ctx = chart.ctx;
                ctx.save();
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, chart.width, chart.height);
                ctx.restore();
            }
        };

        // Set zoom level
        function setZoomLevel(zoom) {
            currentZoomLevel = parseFloat(zoom);
            document.body.style.zoom = currentZoomLevel;
            document.getElementById('zoomValue').textContent = `${Math.round(currentZoomLevel * 100)}%`;
            if (currentPopup) {
                const strike = currentPopup.dataset.strike;
                const cellElement = document.querySelector(`#chainTable td[data-strike="${strike}"]`) ||
                                   document.querySelector(`#chainTable td[data-strike="${strike}"][data-type]`);
                if (cellElement) {
                    const rect = cellElement.getBoundingClientRect();
                    const table = document.getElementById('chainTable');
                    const tableRect = table.getBoundingClientRect();
                    currentPopup.style.left = `${(rect.left - tableRect.left + rect.width) / currentZoomLevel}px`;
                    currentPopup.style.top = `${(rect.top - tableRect.top + rect.height) / currentZoomLevel}px`;
                }
            }
        }

        // Format timestamp with AM/PM
        function formatTimestamp() {
            const now = new Date();
            const options = {
                day: '2-digit',
                month: 'short',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            };
            return now.toLocaleString('en-IN', options).replace(/(\d{2}:\d{2}:\d{2})\s(\w+)/, '$1 $2');
        }

        // Generate time labels from 9:15 AM to 3:40 PM
        function generateTimeLabels() {
            const labels = [];
            let currentTime = new Date();
            currentTime.setHours(9, 15, 0, 0);
            const endTime = new Date();
            endTime.setHours(15, 40, 0, 0);
            while (currentTime <= endTime) {
                labels.push(currentTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }));
                currentTime.setMinutes(currentTime.getMinutes() + 5);
            }
            return labels;
        }

        // Check if same trading day
        function isSameTradingDay(date1, date2) {
            return date1.toISOString().split('T')[0] === date2.toISOString().split('T')[0];
        }

        // Check if trading day
        function isTradingDay(date) {
            const day = date.getDay();
            const dateStr = date.toISOString().split('T')[0];
            return day !== 0 && day !== 6 && !nseHolidays2025[dateStr];
        }

        // Load strike OI change, VOI, and OI data from localStorage
        function loadStrikeOiChangeData() {
            const storedData = localStorage.getItem('strikeOiChangeData');
            if (storedData) {
                const parsedData = JSON.parse(storedData);
                const now = new Date();
                const storedDate = new Date(parsedData.date);
                if (isSameTradingDay(now, storedDate) && isTradingDay(now)) {
                    strikeOiChangeData = new Map(Object.entries(parsedData.data).map(([strike, data]) => [
                        Number(strike),
                        {
                            timestamps: data.timestamps,
                            callOiChg: data.callOiChg,
                            putOiChg: data.putOiChg,
                            peMinusCe: data.peMinusCe,
                            callVoi: data.callVoi || [],
                            putVoi: data.putVoi || [],
                            voiCeMinusPe: data.voiCeMinusPe || [],
                            callOi: data.callOi || [],
                            putOi: data.putOi || [],
                            oiPeMinusCe: data.oiPeMinusCe || []
                        }
                    ]));
                    console.log('Loaded strike OI change, VOI, and OI data from localStorage:', strikeOiChangeData);
                } else {
                    localStorage.removeItem('strikeOiChangeData');
                    strikeOiChangeData = new Map();
                    console.log('Cleared strike OI change, VOI, and OI data: New trading day detected.');
                }
            }
        }

        // Save strike OI change, VOI, and OI data to localStorage
        function saveStrikeOiChangeData() {
            const dataToSave = {
                date: new Date().toISOString().split('T')[0],
                data: Object.fromEntries(strikeOiChangeData)
            };
            localStorage.setItem('strikeOiChangeData', JSON.stringify(dataToSave));
            console.log('Saved strike OI change, VOI, and OI data to localStorage');
        }

        // Initialize Main Chart
        function initializeChart() {
            if (typeof Chart === 'undefined') {
                console.error('Chart.js is not loaded.');
                showErrorMessage('Failed to load Chart.js. Please check your internet connection.');
                return;
            }
            const ctx = document.getElementById('oiChart')?.getContext('2d');
            if (!ctx) {
                console.error('Canvas context not found for oiChart.');
                showErrorMessage('Failed to initialize chart: Canvas not found.');
                return;
            }
            const timeLabels = generateTimeLabels();
            console.log('Initializing main chart with time labels:', timeLabels);

            const initialData = Array(timeLabels.length).fill(null);
            Chart.register(blackBackgroundPlugin);
            oiChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'OI Chg PE',
                            data: initialData.slice(),
                            borderColor: 'green',
                            backgroundColor: 'green',
                            fill: false,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'OI Chg CE',
                            data: initialData.slice(),
                            borderColor: 'red',
                            backgroundColor: 'red',
                            fill: false,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'OI Chg (PE-CE)',
                            data: initialData.slice(),
                            borderColor: 'magenta',
                            backgroundColor: 'magenta',
                            fill: false,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Median Line',
                            data: Array(timeLabels.length).fill(0),
                            borderColor: 'blue',
                            backgroundColor: 'blue',
                            fill: false,
                            pointRadius: 0,
                            borderWidth: 1,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time', color: 'white' }, ticks: { color: 'white' } },
                        y: {
                            title: { display: true, text: 'OI Change (Millions)', color: 'white' },
                            ticks: {
                                callback: function(value) { return (value / 1000000).toFixed(2) + 'M'; },
                                stepSize: 70000,
                                color: 'white'
                            },
                            suggestedMin: -700000,
                            suggestedMax: 700000,
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: 'white',
                                generateLabels: function(chart) {
                                    const labels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                    labels.forEach(label => {
                                        if (label.text === 'OI Chg PE') label.fillStyle = 'green';
                                        if (label.text === 'OI Chg CE') label.fillStyle = 'red';
                                        if (label.text === 'OI Chg (PE-CE)') label.fillStyle = 'magenta';
                                        if (label.text === 'Median Line') label.fillStyle = 'blue';
                                    });
                                    return labels;
                                }
                            }
                        }
                    }
                }
            });
            console.log('Main chart initialized:', oiChart);
        }

        // Update Main Chart Data and Store VOI and OI
        function updateChart(data) {
            if (!oiChart) {
                console.error('Main chart not initialized.');
                return;
            }

            const timestamp = formatTimestamp().split(', ')[1];
            const timeLabels = generateTimeLabels();
            const index = timeLabels.findIndex(label => label === timestamp);

            if (index === -1) {
                console.warn(`Timestamp ${timestamp} not found in chart labels.`);
                return;
            }

            const totalCallOiChg = data.totals?.total_call_oi_chg || 0;
            const totalPutOiChg = data.totals?.total_put_oi_chg || 0;
            const oiChangePEMinusCE = totalPutOiChg - totalCallOiChg;

            console.log('Updating main chart with:', { timestamp, totalPutOiChg, totalCallOiChg, oiChangePEMinusCE, index });

            chartDataPoints.timestamps.push(timestamp);
            chartDataPoints.oiChangePE.push(totalPutOiChg);
            chartDataPoints.oiChangeCE.push(totalCallOiChg);
            chartDataPoints.oiChangePEMinusCE.push(oiChangePEMinusCE);

            if (chartDataPoints.timestamps.length > 100) {
                chartDataPoints.timestamps.shift();
                chartDataPoints.oiChangePE.shift();
                chartDataPoints.oiChangeCE.shift();
                chartDataPoints.oiChangePEMinusCE.shift();
            }

            oiChart.data.datasets[0].data[index] = totalPutOiChg;
            oiChart.data.datasets[1].data[index] = totalCallOiChg;
            oiChart.data.datasets[2].data[index] = oiChangePEMinusCE;
            oiChart.update();
            console.log('Main chart updated with new data at index:', index);

            // Store OI change, VOI, and OI data per strike
            data.chain.forEach(row => {
                const strike = row.strike;
                if (!strikeOiChangeData.has(strike)) {
                    strikeOiChangeData.set(strike, {
                        timestamps: [],
                        callOiChg: [],
                        putOiChg: [],
                        peMinusCe: [],
                        callVoi: [],
                        putVoi: [],
                        voiCeMinusPe: [],
                        callOi: [],
                        putOi: [],
                        oiPeMinusCe: []
                    });
                }
                const strikeData = strikeOiChangeData.get(strike);
                strikeData.timestamps.push(timestamp);
                strikeData.callOiChg.push(row.call_oi_chg || 0);
                strikeData.putOiChg.push(row.put_oi_chg || 0);
                strikeData.peMinusCe.push((row.put_oi_chg || 0) - (row.call_oi_chg || 0));

                // Calculate VOI
                const callVoi = row.call_oi > 0 ? (row.call_vol / row.call_oi * 100) : 0;
                const putVoi = row.put_oi > 0 ? (row.put_vol / row.put_oi * 100) : 0;
                const voiCeMinusPe = callVoi - putVoi;

                strikeData.callVoi.push(callVoi);
                strikeData.putVoi.push(putVoi);
                strikeData.voiCeMinusPe.push(voiCeMinusPe);

                // Store OI
                const callOi = row.call_oi || 0;
                const putOi = row.put_oi || 0;
                const oiPeMinusCe = putOi - callOi;

                strikeData.callOi.push(callOi);
                strikeData.putOi.push(putOi);
                strikeData.oiPeMinusCe.push(oiPeMinusCe);

                if (strikeData.timestamps.length > 100) {
                    strikeData.timestamps.shift();
                    strikeData.callOiChg.shift();
                    strikeData.putOiChg.shift();
                    strikeData.peMinusCe.shift();
                    strikeData.callVoi.shift();
                    strikeData.putVoi.shift();
                    strikeData.voiCeMinusPe.shift();
                    strikeData.callOi.shift();
                    strikeData.putOi.shift();
                    strikeData.oiPeMinusCe.shift();
                }
            });
            saveStrikeOiChangeData();
        }

        // Show Elastic Ends Popup (for strike price clicks)
        function showElasticEndsPopup(strike, cellElement) {
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }

            const current = strikeLevels.get(strike) || { support: 0, resistance: 0 };
            let nineThirty = nineThirtyStrikeLevels.get(strike) || { support: 0, resistance: 0 };
            if (!hasSetNineThirty || !isSameTradingDay(new Date(), new Date(nineThirtyData?.date))) {
                nineThirty = { support: 0, resistance: 0 };
            }

            const popup = document.createElement('div');
            popup.classList.add('inline-popup');
            popup.dataset.strike = strike;
            popup.innerHTML = `
                <div class="popup-content">
                    <h3>Elastic Ends for Strike ${strike}</h3>
                    <div>
                        <p><strong>Current Elastic Ends</strong></p>
                        <p class="resistance">Resistance: ${current.resistance}</p>
                        <p class="support">Support: ${current.support}</p>
                    </div>
                    <div class="divider"></div>
                    <div>
                        <p><strong>9:30 AM Elastic Ends</strong></p>
                        ${hasSetNineThirty && isSameTradingDay(new Date(), new Date(nineThirtyData?.date))
                            ? `<p class="resistance">Resistance: ${nineThirty.resistance}</p>
                               <p class="support">Support: ${nineThirty.support}</p>`
                            : '<p>Not fetched today\'s values at 9:30 AM</p>'}
                    </div>
                    <button>Close</button>
                </div>
            `;

            const rect = cellElement.getBoundingClientRect();
            const table = document.getElementById('chainTable');
            const tableRect = table.getBoundingClientRect();
            popup.style.position = 'absolute';
            popup.style.left = `${(rect.left - tableRect.left + rect.width) / currentZoomLevel}px`;
            popup.style.top = `${(rect.top - tableRect.top + rect.height) / currentZoomLevel}px`;
            table.appendChild(popup);

            currentPopup = popup;

            popup.querySelector('button').onclick = () => {
                popup.remove();
                currentPopup = null;
            };

            document.addEventListener('click', function handler(event) {
                if (!popup.contains(event.target) && !cellElement.contains(event.target)) {
                    popup.remove();
                    currentPopup = null;
                    document.removeEventListener('click', handler);
                }
            }, { once: true });
        }

        // Show OI Change, VOI, and OI Chart Popup (for OI Chg clicks)
        function showOiChangePopup(strike, cellElement, type) {
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }

            const popup = document.createElement('div');
            popup.classList.add('inline-popup');
            popup.dataset.strike = strike;
            popup.innerHTML = `
                <div class="popup-content">
                    <h3>Charts</h3>
                    <canvas id="oiChangeChart" class="popup-chart"></canvas>
                    <div class="divider"></div>
                    <canvas id="voiChart" class="popup-chart"></canvas>
                    <div class="divider"></div>
                    <canvas id="oiChartPopup" class="popup-chart"></canvas>
                    <button>Close</button>
                </div>
            `;

            const rect = cellElement.getBoundingClientRect();
            const table = document.getElementById('chainTable');
            const tableRect = table.getBoundingClientRect();
            popup.style.position = 'absolute';
            popup.style.left = `${(rect.left - tableRect.left + rect.width) / currentZoomLevel}px`;
            popup.style.top = `${(rect.top - tableRect.top + rect.height) / currentZoomLevel}px`;
            table.appendChild(popup);

            currentPopup = popup;

            if (typeof Chart !== 'undefined') {
                const timeLabels = generateTimeLabels();
                const strikeData = strikeOiChangeData.get(strike) || {
                    timestamps: [],
                    callOiChg: [],
                    putOiChg: [],
                    peMinusCe: [],
                    callVoi: [],
                    putVoi: [],
                    voiCeMinusPe: [],
                    callOi: [],
                    putOi: [],
                    oiPeMinusCe: []
                };
                const oiChangeDataPoints = {
                    call: Array(timeLabels.length).fill(null),
                    put: Array(timeLabels.length).fill(null),
                    peMinusCe: Array(timeLabels.length).fill(null)
                };
                const voiDataPoints = {
                    call: Array(timeLabels.length).fill(null),
                    put: Array(timeLabels.length).fill(null),
                    ceMinusPe: Array(timeLabels.length).fill(null)
                };
                const oiDataPoints = {
                    call: Array(timeLabels.length).fill(null),
                    put: Array(timeLabels.length).fill(null),
                    peMinusCe: Array(timeLabels.length).fill(null)
                };

                strikeData.timestamps.forEach((ts, i) => {
                    const index = timeLabels.findIndex(label => label === ts);
                    if (index !== -1) {
                        oiChangeDataPoints.call[index] = strikeData.callOiChg[i];
                        oiChangeDataPoints.put[index] = strikeData.putOiChg[i];
                        oiChangeDataPoints.peMinusCe[index] = strikeData.peMinusCe[i];
                        voiDataPoints.call[index] = strikeData.callVoi[i];
                        voiDataPoints.put[index] = strikeData.putVoi[i];
                        voiDataPoints.ceMinusPe[index] = strikeData.voiCeMinusPe[i];
                        oiDataPoints.call[index] = strikeData.callOi[i];
                        oiDataPoints.put[index] = strikeData.putOi[i];
                        oiDataPoints.peMinusCe[index] = strikeData.oiPeMinusCe[i];
                    }
                });

                // OI Change Chart
                const oiChangeCtx = popup.querySelector('#oiChangeChart')?.getContext('2d');
                if (oiChangeCtx) {
                    new Chart(oiChangeCtx, {
                        type: 'line',
                        plugins: [blackBackgroundPlugin],
                        data: {
                            labels: timeLabels,
                            datasets: [
                                {
                                    label: 'OI Chg PE',
                                    data: oiChangeDataPoints.put,
                                    borderColor: 'green',
                                    backgroundColor: 'green',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'OI Chg CE',
                                    data: oiChangeDataPoints.call,
                                    borderColor: 'red',
                                    backgroundColor: 'red',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'OI Chg (PE-CE)',
                                    data: oiChangeDataPoints.peMinusCe,
                                    borderColor: 'magenta',
                                    backgroundColor: 'magenta',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'Median Line',
                                    data: Array(timeLabels.length).fill(0),
                                    borderColor: 'blue',
                                    backgroundColor: 'blue',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { title: { display: true, text: 'Time', color: 'white' }, ticks: { color: 'white' } },
                                y: {
                                    title: { display: true, text: 'OI Change (Millions)', color: 'white' },
                                    ticks: {
                                        callback: function(value) { return (value / 1000000).toFixed(2) + 'M'; },
                                        stepSize: 70000,
                                        color: 'white'
                                    },
                                    suggestedMin: -700000,
                                    suggestedMax: 700000,
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        color: 'white',
                                        generateLabels: function(chart) {
                                            const labels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                            labels.forEach(label => {
                                                if (label.text === 'OI Chg PE') label.fillStyle = 'green';
                                                if (label.text === 'OI Chg CE') label.fillStyle = 'red';
                                                if (label.text === 'OI Chg (PE-CE)') label.fillStyle = 'magenta';
                                                if (label.text === 'Median Line') label.fillStyle = 'blue';
                                            });
                                            return labels;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    console.log(`OI Change chart initialized for strike ${strike}`);
                }

                // VOI Chart
                const voiCtx = popup.querySelector('#voiChart')?.getContext('2d');
                if (voiCtx) {
                    new Chart(voiCtx, {
                        type: 'line',
                        plugins: [blackBackgroundPlugin],
                        data: {
                            labels: timeLabels,
                            datasets: [
                                {
                                    label: 'VOI CE',
                                    data: voiDataPoints.call,
                                    borderColor: 'green',
                                    backgroundColor: 'green',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'VOI PE',
                                    data: voiDataPoints.put,
                                    borderColor: 'red',
                                    backgroundColor: 'red',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'VOI (CE-PE)',
                                    data: voiDataPoints.ceMinusPe,
                                    borderColor: 'magenta',
                                    backgroundColor: 'magenta',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'Median Line',
                                    data: Array(timeLabels.length).fill(0),
                                    borderColor: 'blue',
                                    backgroundColor: 'blue',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { title: { display: true, text: 'Time', color: 'white' }, ticks: { color: 'white' } },
                                y: {
                                    title: { display: true, text: 'VOI (%)', color: 'white' },
                                    ticks: {
                                        callback: function(value) { return value + '%'; },
                                        stepSize: 10,
                                        color: 'white'
                                    },
                                    suggestedMin: -50,
                                    suggestedMax: 50,
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        color: 'white',
                                        generateLabels: function(chart) {
                                            const labels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                            labels.forEach(label => {
                                                if (label.text === 'VOI CE') label.fillStyle = 'green';
                                                if (label.text === 'VOI PE') label.fillStyle = 'red';
                                                if (label.text === 'VOI (CE-PE)') label.fillStyle = 'magenta';
                                                if (label.text === 'Median Line') label.fillStyle = 'blue';
                                            });
                                            return labels;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    console.log(`VOI chart initialized for strike ${strike}`);
                }

                // OI Chart
                const oiCtx = popup.querySelector('#oiChartPopup')?.getContext('2d');
                if (oiCtx) {
                    new Chart(oiCtx, {
                        type: 'line',
                        plugins: [blackBackgroundPlugin],
                        data: {
                            labels: timeLabels,
                            datasets: [
                                {
                                    label: 'OI PE',
                                    data: oiDataPoints.put,
                                    borderColor: 'green',
                                    backgroundColor: 'green',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'OI CE',
                                    data: oiDataPoints.call,
                                    borderColor: 'red',
                                    backgroundColor: 'red',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'OI (PE-CE)',
                                    data: oiDataPoints.peMinusCe,
                                    borderColor: 'magenta',
                                    backgroundColor: 'magenta',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'Median Line',
                                    data: Array(timeLabels.length).fill(0),
                                    borderColor: 'blue',
                                    backgroundColor: 'blue',
                                    fill: false,
                                    pointRadius: 0,
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { title: { display: true, text: 'Time', color: 'white' }, ticks: { color: 'white' } },
                                y: {
                                    title: { display: true, text: 'OI (Millions)', color: 'white' },
                                    ticks: {
                                        callback: function(value) { return (value / 1000000).toFixed(2) + 'M'; },
                                        stepSize: 70000,
                                        color: 'white'
                                    },
                                    suggestedMin: -700000,
                                    suggestedMax: 700000,
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        color: 'white',
                                        generateLabels: function(chart) {
                                            const labels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                            labels.forEach(label => {
                                                if (label.text === 'OI PE') label.fillStyle = 'green';
                                                if (label.text === 'OI CE') label.fillStyle = 'red';
                                                if (label.text === 'OI (PE-CE)') label.fillStyle = 'magenta';
                                                if (label.text === 'Median Line') label.fillStyle = 'blue';
                                            });
                                            return labels;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    console.log(`OI chart initialized for strike ${strike}`);
                }
            } else {
                console.error('Failed to initialize popup charts: Chart.js or canvas not found.');
                popup.innerHTML = `
                    <div class="popup-content">
                        <h3>Charts</h3>
                        <p>Failed to load charts. Please refresh the page.</p>
                        <button>Close</button>
                    </div>
                `;
            }

            popup.querySelector('button').onclick = () => {
                popup.remove();
                currentPopup = null;
            };

            document.addEventListener('click', function handler(event) {
                if (!popup.contains(event.target) && !cellElement.contains(event.target)) {
                    popup.remove();
                    currentPopup = null;
                    document.removeEventListener('click', handler);
                }
            }, { once: true });
        }

        // Debounce utility
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Throttle utility
        function throttle(func) {
            return function (...args) {
                const now = Date.now();
                if (now - lastFetchTime >= MIN_FETCH_INTERVAL) {
                    lastFetchTime = now;
                    return func(...args);
                } else {
                    console.log('Throttled fetch attempt');
                }
            };
        }

        // Navigation menu toggle
        function toggleNavMenu() {
            const navMenu = document.querySelector('.nav-menu');
            navMenu.classList.toggle('open');
        }

        // Toggle dropdown on mobile
        function toggleDropdown(event) {
            event.stopPropagation(); // Prevent event from bubbling up
            const dropdown = event.target.closest('.dropdown');
            if (dropdown) {
                dropdown.classList.toggle('active');
                
                // Keep dropdown open while interacting with select
                const select = dropdown.querySelector('select');
                if (select) {
                    select.addEventListener('click', (e) => e.stopPropagation());
                    select.addEventListener('change', (e) => e.stopPropagation());
                }
            }
        }

        // Add document click handler to close dropdowns
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.dropdown')) {
                document.querySelectorAll('.dropdown').forEach(dropdown => {
                    if (!dropdown.contains(event.target)) {
                        dropdown.classList.remove('active');
                    }
                });
            }
        });

        // Update existing event listeners
        document.querySelectorAll('.nav-menu a, .dropdown').forEach(element => {
            element.addEventListener('click', (event) => {
                if (window.innerWidth <= 768) {
                    if (element.classList.contains('dropdown')) {
                        toggleDropdown(event);
                    } else if (!element.closest('select') && 
                             !element.closest('input[type="radio"]') && 
                             !element.closest('#zoomLevel')) {
                        document.querySelector('.nav-menu').classList.remove('open');
                    }
                }
            });
        });

        // Show rate limit message
        function showRateLimitMessage() {
            const rateLimitDiv = document.getElementById('rateLimitMessage');
            if (rateLimitDiv) {
                rateLimitDiv.style.display = 'block';
            }
        }

        // Hide rate limit message
        function hideRateLimitMessage() {
            const rateLimitDiv = document.getElementById('rateLimitMessage');
            if (rateLimitDiv) {
                rateLimitDiv.style.display = 'none';
            }
        }

        let scripList = []; // Store scrips with scrip_id, segment, symbol

        // Fetch scrips and populate dropdown
        async function fetchScrips() {
            try {
                const response = await fetch(`${BASE_URL}/get_all_scrips`);
                if (!response.ok) {
                    console.error('Failed to fetch /get_all_scrips:', response.status, response.statusText);
                    showErrorMessage('Failed to fetch scrips: ' + response.statusText);
                    return;
                }
                const data = await response.json();
                if (data.error) {
                    showErrorMessage('Backend error: ' + data.error);
                    return;
                }
                if (!Array.isArray(data) || data.length === 0) {
                    showErrorMessage('No scrips available for dropdown.');
                    return;
                }
                scripList = data;
                renderScrips(data);
            } catch (error) {
                showErrorMessage('Failed to fetch scrips');
                console.error('Fetch error:', error);
            }
        }

        // Render scrips in dropdown by symbol name
        function renderScrips(data) {
            const scripSelect = document.getElementById('scrip');
            scripSelect.innerHTML = '<option value="" disabled selected>Select a scrip</option>';
            
            console.log('Dropdown data:', data); // Debug: show received data
            data.forEach(scrip => {
                // Fallback if symbol is missing
                const symbol = scrip.symbol || 'Unknown';
                const option = document.createElement('option');
                option.value = scrip.scrip_id + '|' + scrip.segment;
                option.text = symbol;
                scripSelect.appendChild(option);
            });
            scripSelect.disabled = false; // Ensure dropdown is enabled
        }

        // On dropdown change, extract scrip_id and segment, then fetch option chain
        document.getElementById('scrip').addEventListener('change', () => {
            stopFetching();
            previousChainData = null;
            previousMaxStrikes = { callOi: null, callOiChg: null, callVol: null, putOi: null, putOiChg: null, putVol: null };
            chartDataPoints = { timestamps: [], oiChangePE: [], oiChangeCE: [], oiChangePEMinusCE: [] };
            if (oiChart) {
                const timeLabels = generateTimeLabels();
                oiChart.data.datasets[0].data = Array(timeLabels.length).fill(null);
                oiChart.data.datasets[1].data = Array(timeLabels.length).fill(null);
                oiChart.data.datasets[2].data = Array(timeLabels.length).fill(null);
                oiChart.update();
            }
            // Extract selected scrip details
            const selected = document.getElementById('scrip').value;
            if (!selected) return;
            const [scrip_id, segment] = selected.split('|');
            // Store for option chain fetch
            window.selectedScripId = scrip_id;
            window.selectedSegment = segment;
            fetchExpiries();
        });

        // Update fetchExpiries and fetchChain to use selectedScripId and selectedSegment
        async function fetchExpiries() {
            const scrip_id = window.selectedScripId;
            const segment = window.selectedSegment;
            
            if (!scrip_id || !segment) {
                showErrorMessage('Please select a scrip.');
                return;
            }

            try {
                const response = await fetch(`${BASE_URL}/get_expiries`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        underlying_scrip: parseInt(scrip_id),
                        underlying_seg: segment
                    })
                });
                
                const data = await response.json();
                if (!data.data) {
                    throw new Error(data.error || 'Invalid response format');
                }
                
                cachedExpiries = { scrip: scrip_id, seg: segment, data: data.data };
                renderExpiries(data.data);
                
            } catch (error) {
                console.error('Fetch error:', error);
                showErrorMessage(error.message);
            }
        }

        // Render expiries
        function renderExpiries(expiries) {
            const ExpSelect = document.getElementById('ExpDate');
            ExpSelect.innerHTML = '<option value="" disabled>Select a date</option>';            
            if (!expiries || !Array.isArray(expiries) || expiries.length === 0) {
                showErrorMessage('No valid expiry dates available in response.');
                return;
            }

            console.log('Dropdown data:', expiries); // Debug: show received data
        
            // Populate dropdown with values from JSON
            expiries.forEach(item => {
                const option = document.createElement('option');
                option.value = item; 
                option.textContent = String(item); 
                ExpSelect.appendChild(option);
            });
            ExpSelect.disabled = false; // Ensure dropdown is enabled


            // selectedExpiry = expiries[0];
            // console.log('Selected expiry:', selectedExpiry);
            // startFetching();
        }

        // Fetch option chain
        async function fetchChain() {
            const scrip_id = window.selectedScripId;
            const segment = window.selectedSegment;
            const strikeOption = document.querySelector('input[name="strikeOption"]:checked')?.value || '12';
            const tableOrder = document.querySelector('input[name="tableOrder"]:checked')?.value || 'descending';
            const expiry = selectedExpiry;

            if (!scrip_id || !segment || !expiry) {
                showErrorMessage('Please select a scrip and ensure an expiry is available.');
                return;
            }
            const requestBody = { underlying_scrip: parseInt(scrip_id), underlying_seg: segment, expiry };
            console.log('Sending request to /get_option_chain:', JSON.stringify(requestBody, null, 2));
            if (lastRequestBody && JSON.stringify(requestBody) === JSON.stringify(lastRequestBody) &&
                strikeOption === lastRequestBody.strikeOption && tableOrder === lastRequestBody.tableOrder) {
                console.log('Skipping duplicate fetch with same parameters');
                return;
            }

            lastRequestBody = { ...requestBody, strikeOption, tableOrder };
            console.log('Fetching chain with:', JSON.stringify(requestBody, null, 2), 'strikeOption:', strikeOption, 'tableOrder:', tableOrder);

            async function attemptFetch(attempt) {
                try {
                    const response = await fetch(`${BASE_URL}/get_option_chain`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json; charset=utf-8' },
                        body: JSON.stringify(requestBody)
                    });
                    if (!response.ok) {
                        console.error('Failed to fetch /get_option_chain:', response.status, response.statusText);
                    }
                    const data = await response.json();
                    console.log('Raw chain response:', JSON.stringify(data, null, 2));
                    if (data.error) {
                        showErrorMessage(`Error fetching chain: ${data.error}`);
                        return;
                    }

                    if (!data.chain || !data.totals || !data.atm_strike) {
                        showErrorMessage('Invalid option chain data received.');
                        return;
                    }

                    underlyingValue = data.spot_price || data.underlying_price || 0;
                    checkAndSetNineThirtyData(data);
                    renderTable(data, strikeOption, tableOrder);
                    updateChart(data);
                    previousChainData = data;
                    removeErrorMessage();
                    hideRateLimitMessage();
                    retryCount = 0;
                } catch (error) {
                    showErrorMessage(`Failed to fetch chain: ${error.message}`);
                    console.error('Fetch error:', error);
                }
            }

            await attemptFetch(1);
        }

        // Render table
        // function renderTable(data, strikeOption, tableOrder) {
        //     const tbody = document.getElementById('chainBody');
        //     const tfoot = document.getElementById('totalsFoot');
        //     const dateTimeHeader = document.getElementById('dateTimeHeader');

        //     const timestamp = formatTimestamp();
        //     const [date, time] = timestamp.split(', ');
        //     dateTimeHeader.innerHTML = `${date}<br>${time}`;

        //     let filteredChain = data.chain;
        //     if (strikeOption === '12') {
        //         const spotPrice = underlyingValue;
        //         if (spotPrice === 0) {
        //             console.warn('Spot price unavailable, showing all strikes.');
        //         } else {
        //             const sortedStrikes = data.chain.map(row => row.strike).sort((a, b) => a - b);
        //             const strikesAbove = sortedStrikes.filter(strike => strike >= spotPrice).slice(0, 12);
        //             const strikesBelow = sortedStrikes.filter(strike => strike < spotPrice).slice(-12);
        //             const selectedStrikes = [...strikesBelow, ...strikesAbove].sort((a, b) => a - b);
        //             filteredChain = data.chain.filter(row => selectedStrikes.includes(row.strike));
        //         }
        //     }

        //     filteredChain.sort((a, b) => tableOrder === 'ascending' ? a.strike - b.strike : b.strike - a.strike);

        //     const maxValues = {
        //         callOiChg: { max: 0, second: 0, third: 0, maxStrike: null },
        //         callOi: { max: 0, second: 0, third: 0, maxStrike: null },
        //         callVol: { max: 0, second: 0, third: 0, maxStrike: null },
        //         putVol: { max: 0, second: 0, third: 0, maxStrike: null },
        //         putOi: { max: 0, second: 0, third: 0, maxStrike: null },
        //         putOiChg: { max: 0, second: 0, third: 0, maxStrike: null }
        //     };

        //     const getTopThree = (values, strikes) => {
        //         const validValues = values
        //             .map((v, i) => ({ value: v, strike: strikes[i] }))
        //             .filter(item => item.value > 0)
        //             .sort((a, b) => b.value - a.value);
        //         return {
        //             max: validValues[0]?.value || 0,
        //             second: validValues[1]?.value || 0,
        //             third: validValues[2]?.value || 0,
        //             maxStrike: validValues[0]?.strike || null
        //         };
        //     };

        //     const strikes = filteredChain.map(row => row.strike);
        //     maxValues.callOiChg = getTopThree(filteredChain.map(row => row.call_oi_chg >= 0 ? row.call_oi_chg : 0), strikes);
        //     maxValues.callOi = getTopThree(filteredChain.map(row => row.call_oi >= 0 ? row.call_oi : 0), strikes);
        //     maxValues.callVol = getTopThree(filteredChain.map(row => Math.abs(row.call_vol || 0)), strikes);
        //     maxValues.putVol = getTopThree(filteredChain.map(row => Math.abs(row.put_vol || 0)), strikes);
        //     maxValues.putOi = getTopThree(filteredChain.map(row => row.put_oi >= 0 ? row.put_oi : 0), strikes);
        //     maxValues.putOiChg = getTopThree(filteredChain.map(row => row.put_oi_chg >= 0 ? row.put_oi_chg : 0), strikes);

        //     const shifts = [];
        //     const metrics = [
        //         { key: 'callOi', name: 'Call OI', current: maxValues.callOi.maxStrike, previous: previousMaxStrikes.callOi },
        //         { key: 'callOiChg', name: 'Call OI Chg', current: maxValues.callOiChg.maxStrike, previous: previousMaxStrikes.callOiChg },
        //         { key: 'callVol', name: 'Call Vol', current: maxValues.callVol.maxStrike, previous: previousMaxStrikes.callVol },
        //         { key: 'putOi', name: 'Put OI', current: maxValues.putOi.maxStrike, previous: previousMaxStrikes.putOi },
        //         { key: 'putOiChg', name: 'Put OI Chg', current: maxValues.putOiChg.maxStrike, previous: previousMaxStrikes.putOiChg },
        //         { key: 'putVol', name: 'Put Vol', current: maxValues.putVol.maxStrike, previous: previousMaxStrikes.putVol }
        //     ];

        //     if (previousChainData) {
        //         metrics.forEach(metric => {
        //             if (metric.current !== null && metric.previous !== null && metric.current !== metric.previous) {
        //                 const direction = metric.current > metric.previous ? 'up' : 'down';
        //                 const timestamp = formatTimestamp().split(', ')[1];
        //                 shifts.push({
        //                     metric: metric.name,
        //                     from: metric.previous,
        //                     to: metric.current,
        //                     direction: direction,
        //                     timestamp: timestamp
        //                 });
        //             }
        //         });
        //     }

        //     previousMaxStrikes = {
        //         callOi: maxValues.callOi.maxStrike,
        //         callOiChg: maxValues.callOiChg.maxStrike,
        //         callVol: maxValues.callVol.maxStrike,
        //         putOi: maxValues.putOi.maxStrike,
        //         putOiChg: maxValues.putOiChg.maxStrike,
        //         putVol: maxValues.putVol.maxStrike
        //     };

        //     const spotPrice = underlyingValue;
        //     let spotRowIndex = -1;
        //     if (spotPrice > 0) {
        //         const sortedStrikes = filteredChain.map(row => row.strike);
        //         spotRowIndex = tableOrder === 'ascending'
        //             ? sortedStrikes.findIndex((strike, index) => index < sortedStrikes.length - 1 && strike <= spotPrice && sortedStrikes[index + 1] > spotPrice)
        //             : sortedStrikes.findIndex((strike, index) => index < sortedStrikes.length - 1 && strike > spotPrice && sortedStrikes[index + 1] <= spotPrice);
        //     }

        //     const fragment = document.createDocumentFragment();
        //     let spotRowInserted = false;

        //     if (shifts.length > 0) {
        //         shifts.forEach(shift => {
        //             const shiftRow = document.createElement('tr');
        //             shiftRow.classList.add('shift-row');
        //             const message = `${shift.metric} --> ${shift.from.toFixed(2)} --> ${shift.to.toFixed(2)} at ${shift.timestamp}`;
        //             shiftRow.innerHTML = `<td colspan="7"></td><td><span class="shift-${shift.direction}">${message}</span></td><td colspan="7"></td>`;
        //             fragment.appendChild(shiftRow);
        //         });
        //     }

        //     filteredChain.forEach((row, index) => {
        //         if (!spotRowInserted && spotPrice > 0 && spotRowIndex !== -1 && index === spotRowIndex + 1) {
        //             const spotRow = document.createElement('tr');
        //             spotRow.classList.add('spot-row');
        //             spotRow.innerHTML = `<td colspan="7"></td><td>Spot Price: ${spotPrice.toFixed(2)}</td><td colspan="7"></td>`;
        //             fragment.appendChild(spotRow);
        //             spotRowInserted = true;
        //         }

        //         const dataRow = document.createElement('tr');
        //         if (spotPrice > 0 && row.strike < spotPrice) {
        //             dataRow.classList.add('itm');
        //         } else if (spotPrice > 0 && row.strike > spotPrice) {
        //             dataRow.classList.add('otm');
        //         }

        //         function createTd(value, isChg = false, isMillion = false, maxValue = null, isPut = false, isOiOrOiChg = false, isStrike = false, isOiChange = false, type = null) {
        //             const td = document.createElement('td');
        //             if (isMillion && value !== null && value !== undefined && Number.isFinite(value)) {
        //                 let percent;
        //                 let className = '';
        //                 if (isOiOrOiChg && value < 0) {
        //                     percent = '0';
        //                 } else {
        //                     percent = maxValue.max > 0 ? (value / maxValue.max * 100).toFixed(1) : '0';
        //                     if (value === maxValue.max) {
        //                         className = isPut ? 'highest-value-put' : 'highest-value-call';
        //                     } else if (value === maxValue.second && percent > 75) {
        //                         className = 'second-highest';
        //                     } else if (value === maxValue.third && percent > 75) {
        //                         className = 'third-highest';
        //                     }
        //                 }
        //                 td.textContent = `${percent}%\n${(value / 1000000).toFixed(1)}M`;
        //                 if (className) {
        //                     td.classList.add(className);
        //                 }
        //             } else {
        //                 td.textContent = value !== null && value !== undefined ? Number.isFinite(value) ? value.toFixed(2) : value : '-';
        //             }
        //             if (isChg && Number.isFinite(value)) {
        //                 if (value > 0) td.classList.add('positive');
        //                 else if (value < 0) td.classList.add('negative');
        //             }
        //             if (isStrike || isOiChange) {
        //                 td.style.cursor = 'pointer';
        //                 td.dataset.strike = row.strike;
        //                 if (isOiChange) {
        //                     td.dataset.type = type;
        //                     td.addEventListener('click', (event) => showOiChangePopup(row.strike, td, type));
        //                 } else {
        //                     td.addEventListener('click', (event) => showElasticEndsPopup(row.strike, td));
        //                 }
        //             }
        //             return td;
        //         }

        //         dataRow.appendChild(createTd(row.call_iv));
        //         dataRow.appendChild(createTd(row.call_tv));
        //         dataRow.appendChild(createTd(row.call_oi_chg, true, true, maxValues.callOiChg, false, true, false, true, 'call'));
        //         dataRow.appendChild(createTd(row.call_oi, false, true, maxValues.callOi, false, true));
        //         dataRow.appendChild(createTd(row.call_vol, false, true, maxValues.callVol));
        //         dataRow.appendChild(createTd(row.call_chg_pct, true));
        //         dataRow.appendChild(createTd(row.call_ltp));
        //         dataRow.appendChild(createTd(row.strike, false, false, null, false, false, true));
        //         dataRow.appendChild(createTd(row.put_ltp));
        //         dataRow.appendChild(createTd(row.put_chg_pct, true));
        //         dataRow.appendChild(createTd(row.put_vol, false, true, maxValues.putVol, true));
        //         dataRow.appendChild(createTd(row.put_oi, false, true, maxValues.putOi, true, true));
        //         dataRow.appendChild(createTd(row.put_oi_chg, true, true, maxValues.putOiChg, true, true, false, true, 'put'));
        //         dataRow.appendChild(createTd(row.put_tv));
        //         dataRow.appendChild(createTd(row.put_iv));

        //         fragment.appendChild(dataRow);
        //     });

        //     if (!spotRowInserted && spotPrice > 0) {
        //         const spotRow = document.createElement('tr');
        //         spotRow.classList.add('spot-row');
        //         spotRow.innerHTML = `<td colspan="7"></td><td>Spot Price: ${spotPrice.toFixed(2)}</td><td colspan="7"></td>`;
        //         fragment.appendChild(spotRow);
        //     }

        //     const totalRow = document.createElement('tr');
        //     totalRow.classList.add('total-row');
        //     totalRow.innerHTML = `
        //         <td></td>
        //         <td></td>
        //         <td></td>
        //         <td>${data.totals.total_call_oi !== undefined ? (data.totals.total_call_oi / 1000000).toFixed(1) + 'M' : '-'}</td>
        //         <td>${data.totals.total_call_vol !== undefined ? (data.totals.total_call_vol / 1000000).toFixed(1) + 'M' : '-'}</td>
        //         <td></td>
        //         <td></td>
        //         <td></td>
        //         <td></td>
        //         <td></td>
        //         <td>${data.totals.total_put_vol !== undefined ? (data.totals.total_put_vol / 1000000).toFixed(1) + 'M' : '-'}</td>
        //         <td>${data.totals.total_put_oi !== undefined ? (data.totals.total_put_oi / 1000000).toFixed(1) + 'M' : '-'}</td>
        //         <td></td>
        //         <td></td>
        //         <td></td>
        //     `;
        //     const pcrRow = document.createElement('tr');
        //     pcrRow.classList.add('pcr-row');
        //     pcrRow.innerHTML = `
        //         <td colspan="15">Total PCR OI: ${data.totals.total_pcr_oi !== undefined ? data.totals.total_pcr_oi.toFixed(2) : '-'} | Total PCR Vol: ${data.totals.total_pcr_vol !== undefined ? data.totals.total_pcr_vol.toFixed(2) : '-'}</td>
        //     `;
        //     tfoot.innerHTML = '';
        //     tfoot.appendChild(totalRow);
        //     tfoot.appendChild(pcrRow);

        //     tbody.innerHTML = '';
        //     tbody.appendChild(fragment);
        //     document.getElementById('chainTable').style.display = 'table';

        //     calculateStrikeLevels(data.chain);
        //     if (nineThirtyData) {
        //         calculateNineThirtyStrikeLevels();
        //     }
        // }

        // Calculate time to expiry in years with intraday precision
        function calculateT() {
            const now = new Date();
            const expiryDate = new Date(`${selectedExpiry}T15:30:00+05:30`);
            const diffMs = expiryDate - now;

            if (diffMs <= 0) {
                return 0;
            }

            const diffHours = diffMs / (1000 * 60 * 60);
            const isSameDay = now.toISOString().split('T')[0] === selectedExpiry;

            if (isSameDay && diffHours <= 1) {
                const diffMinutes = diffMs / (1000 * 60);
                return Math.max(0, diffMinutes / (365 * 24 * 60));
            } else if (isSameDay && diffHours <= 24) {
                return Math.max(0, diffHours / (365 * 24));
            } else {
                const diffDays = diffMs / (1000 * 60 * 60 * 24);
                return Math.max(0, diffDays / 365);
            }
        }

        // Calculate reversal (support/resistance)
        function calculateReversal(row, useNineThirty = false) {
            let S = underlyingValue;
            let P = row.put_ltp;
            let C = row.call_ltp;
            const K = row.strike;

            if (useNineThirty && nineThirtyData) {
                S = nineThirtyData.s;
                const strikeData = nineThirtyData.strikes.get(K);
                if (strikeData) {
                    P = strikeData.p;
                    C = strikeData.c;
                } else {
                    return 0;
                }
            }

            const t = calculateT();
            const exp_term = Math.exp(-RISK_FREE_RATE * t);
            const one_minus_exp = 1 - exp_term;
            const reversal = S - K + P - C + K * one_minus_exp;
            return K + reversal;
        }

        // Calculate strike levels
        function calculateStrikeLevels(chain) {
            const sortedChain = [...chain].sort((a, b) => a.strike - b.strike);
            if (sortedChain.length < 1) return;

            strikeLevels.clear();
            const step = sortedChain.length > 1 ? sortedChain[1].strike - sortedChain[0].strike : 50;

            const lowestRow = sortedChain[0];
            const hypotheticalLow = { ...lowestRow, strike: lowestRow.strike - step };
            const lowSupport = calculateReversal(hypotheticalLow);

            for (let i = 0; i < sortedChain.length; i++) {
                const row = sortedChain[i];
                const support = i === 0 ? lowSupport : calculateReversal(row);
                let resistance;
                if (i < sortedChain.length - 1) {
                    resistance = calculateReversal(sortedChain[i + 1]);
                } else {
                    const hypotheticalHigh = { ...row, strike: row.strike + step };
                    resistance = calculateReversal(hypotheticalHigh);
                }
                strikeLevels.set(row.strike, { support: support.toFixed(4), resistance: resistance.toFixed(4) });
            }
        }

        // Calculate nine thirty strike levels
        function calculateNineThirtyStrikeLevels() {
            if (!nineThirtyData || !nineThirtyData.strikes.size) return;

            const strikesArray = Array.from(nineThirtyData.strikes.keys()).sort((a, b) => a - b);
            const chain = strikesArray.map(strike => ({
                strike,
                put_ltp: nineThirtyData.strikes.get(strike).p,
                call_ltp: nineThirtyData.strikes.get(strike).c
            }));

            nineThirtyStrikeLevels.clear();
            const step = strikesArray.length > 1 ? strikesArray[1] - strikesArray[0] : 50;

            const lowestStrike = strikesArray[0];
            const lowestData = nineThirtyData.strikes.get(lowestStrike);
            const hypotheticalLow = { strike: lowestStrike - step, put_ltp: lowestData.p, call_ltp: lowestData.c };
            const lowSupport = calculateReversal(hypotheticalLow, true);

            for (let i = 0; i < strikesArray.length; i++) {
                const row = chain[i];
                const support = i === 0 ? lowSupport : calculateReversal(row, true);
                let resistance;
                if (i < strikesArray.length - 1) {
                    resistance = calculateReversal(chain[i + 1], true);
                } else {
                    const hypotheticalHigh = { ...row, strike: row.strike + step };
                    resistance = calculateReversal(hypotheticalHigh, true);
                }
                nineThirtyStrikeLevels.set(row.strike, { support: support.toFixed(4), resistance: resistance.toFixed(4) });
            }
        }

        // Load nine thirty data from localStorage
        function loadNineThirtyData() {
            const storedData = localStorage.getItem('nineThirtyData');
            if (storedData) {
                const parsedData = JSON.parse(storedData);
                const now = new Date();
                const storedDate = new Date(parsedData.date);
                if (isSameTradingDay(now, storedDate)) {
                    nineThirtyData = {
                        s: parsedData.s,
                        strikes: new Map(Object.entries(parsedData.strikes).map(([k, v]) => [Number(k), v])),
                        date: parsedData.date
                    };
                    nineThirtyStrikeLevels = new Map(Object.entries(parsedData.strikeLevels || {}).map(([k, v]) => [Number(k), v]));
                    hasSetNineThirty = true;
                } else {
                    localStorage.removeItem('nineThirtyData');
                    nineThirtyData = null;
                    nineThirtyStrikeLevels = new Map();
                    hasSetNineThirty = false;
                }
            }
        }

        // Check and set nine thirty data
        function checkAndSetNineThirtyData(data) {
            const now = new Date();
            const isTrading = isTradingDay(now);
            if (isTrading && !hasSetNineThirty) {
                const nineThirty = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 9, 30, 0);
                if (now >= nineThirty && now <= new Date(now.getFullYear(), now.getMonth(), now.getDate(), 9, 31, 0)) {
                    setNineThirtyData(data);
                }
            }
        }

        // Set nine thirty data
        function setNineThirtyData(data) {
            if (nineThirtyData || !data.chain.length) return;

            nineThirtyData = {
                s: data.underlying_price,
                strikes: new Map(),
                date: new Date().toISOString().split('T')[0]
            };
            data.chain.forEach(row => {
                nineThirtyData.strikes.set(row.strike, { p: row.put_ltp, c: row.call_ltp });
            });
            saveNineThirtyData();
            calculateNineThirtyStrikeLevels();
            hasSetNineThirty = true;
        }

        // Save nine thirty data to localStorage
        function saveNineThirtyData() {
            if (nineThirtyData) {
                const dataToSave = {
                    s: nineThirtyData.s,
                    strikes: Object.fromEntries(nineThirtyData.strikes),
                    date: nineThirtyData.date,
                    strikeLevels: Object.fromEntries(nineThirtyStrikeLevels)
                };
                localStorage.setItem('nineThirtyData', JSON.stringify(dataToSave));
            }
        }

        // Start and stop fetching
        function startFetching() {
            debouncedFetchChain();
            fetchInterval = setInterval(debouncedFetchChain, 1000);
        }

        function stopFetching() {
            if (fetchInterval) {
                clearInterval(fetchInterval);
                fetchInterval = null;
            }
            hideRateLimitMessage();
        }

        // Debounced and throttled fetchChain
        const debouncedFetchChain = debounce(throttle(fetchChain), 500);

        // Error handling
        function showErrorMessage(message) {
            isError = true;
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
            console.log('Error displayed:', message);
            stopFetching();
        }

        function removeErrorMessage() {
            isError = false;
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }

        document.querySelectorAll('input[name="strikeOption"], input[name="tableOrder"]').forEach(input => {
            input.addEventListener('change', debouncedFetchChain);
        });
        document.querySelector('.hamburger').addEventListener('click', toggleNavMenu);
        document.querySelectorAll('.nav-menu a, .dropdown').forEach(element => {
            element.addEventListener('click', (event) => {
                if (window.innerWidth <= 768) {
                    if (element.classList.contains('dropdown')) {
                        toggleDropdown(event);
                    } else if (!element.closest('select') && 
                             !element.closest('input[type="radio"]') && 
                             !element.closest('#zoomLevel')) {
                        document.querySelector('.nav-menu').classList.remove('open');
                    }
                }
            });
        });

        // Initialize chart after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Instead, just try to initializeChart if Chart is available
            // if (typeof Chart !== 'undefined') {
            //     initializeChart();
            // }
            // loadNineThirtyData();
            // loadStrikeOiChangeData();
            fetchScrips();
        });
    </script>
</body>
</html>